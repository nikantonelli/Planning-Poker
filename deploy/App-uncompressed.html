<!DOCTYPE html>
<html>
<head>
    <title>PlanningGame</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('Niks.Apps.PlanningGame', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    itemId: 'pokerApp',

    //Only save the least amount of data in here. We only have 32768 chars to play with
    _GC: {},

    config: {
        configFieldName: "c_PlanningPokerConfig",
        configSplitter: '^',
        showVotePanel: false    //Initial view for Moderator
    },

    statics: {
        SAVE_FAIL_RETRIES: 5
    },

    listeners: {
        removeGame: function() {
            var filters = [];
            //Get all the message types from array
            _.each(Object.keys(pokerMsg), function (msg) {
                filters.push({
                    property: 'Text',
                    operator: 'contains',
                    value: pokerMsg[msg]
                });
            });
            var me = this;
            //Remove all tagged conversation posts for stories in the project node and remove the contents of the Project custom field
            Ext.create('Rally.ui.dialog.ConfirmDialog', {
                title: 'Clean up from game',
                message: "Remove all game generated posts?",
                confirmLabel: 'Yes',
                listeners: {
                    confirm: function() {
                        Ext.create('Rally.data.wsapi.Store', {
                            model: 'ConversationPost',
                            filters: Rally.data.wsapi.Filter.or(filters),
                            autoLoad: true,
                            context: me.getContext().getDataContext(),
                            listeners: {
                                load: function(store, records, successful) {
                                    var recordCount = records.length;
                                    var promises = [];
                                    if (successful) {
                                        _.each(records, function(record) {
                                            promises.push(record.destroy());   //Dangerous, but necessary.
                                        });
                                        Deft.Promise.all(promises).then({
                                            success: function() {
                                                Rally.ui.notify.Notifier.showWarning({ message: Ext.String.format(' {0} Records Deleted', recordCount)});
                                                me._reloadGame();
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    }
                }
            });
        },

        switchpanel: function() {
            if ( this.showVotePanel ) {
                this.showVotePanel = false;
                this.userPage.hide();
                this.modPage.show();
            }
            else {
                this.showVotePanel = true;
                this.userPage.show();
                this.modPage.hide();                
            }
        },

        //These two can be triggered from the config panel.
        adduser: function(user) {
            this._MC.addExtraUser(user);
            this._GC.addExtraUser(user);
        },

        removeuser: function(user) {
            this._MC.removeExtraUser(user);
            this._GC.removeExtraUser(user);
        },
        
        configsaver: function() {
            this._saveProjectConfig();
        },

        configchanged: function() {
            var me = this;
            me._UC.setConfig(me._GC.getNamedConfig(userConfigName)); 
            me._MC.setConfig(me._GC.getNamedConfig(userConfigName)); 
            me._IC.setConfig(me._GC.getNamedConfig(iterConfigName));
            //GC itself updates directly from panel, so no need to fetch here
            this._saveProjectConfig().then({
                success: function(result) {
                    /** Config saved and restart from scratch */
                    me._reloadGame();
                },
                failure: function(e) {
                    console.log("Failed to save project config",e);
                },
                scope: this
            });
        },
        refresh: function() {
            var me = this;
            Rally.ui.notify.Notifier.show({message: 'Refreshing Game'});

            /** We may not do anything with the config at this point. We can catch team member changes on restart. So, really we only need 
             * to catch story changes
            */
            me._startGame();
        },
        showConfig: function() {
            if (this._iAmModerator()){
                this._GC.showPanel();
            }
        },
        changeIteration: function() {
            if (this._iAmModerator()){
                this._IC.showPanel();
            }
        },
        cardselected: function(story) {
            console.log('cardselected: ', story);
            this._UC.selectCard(story,this._GC.getNamedConfig(mainConfigName));
            if (this._iAmModerator()) {
                this._MC.selectCard(story,this._GC.getNamedConfig(mainConfigName));
            }
            this._storySelected = story;    //Send message to other users when asked to post the vote
        },

        voteselected: function(vote) {
            this._voteSelected = vote;
            this._UC.setVote(vote);
        },

        postvote: function() {
            var me = this;
            if (this._voteSelected && this._storySelected) {
                Rally. data.ModelFactory.getModel({
                    type: 'ConversationPost',
                    success: function(model) {
                        var record = Ext.create(model, {
                            Text: '<p>'+pokerMsg.votePosted+":"+JSON.stringify(me._voteSelected)+'</p>',
                            Artifact: me._storySelected.story.get('_ref'),
                        });
                        record.save({
                            callback: function(result, operation) {
                                if (operation.wasSuccessful()) {
                                    Rally.ui.notify.Notifier.show({message: Ext.String.format('Vote Posted on {0} was {1}',
                                        me._storySelected.story.get('FormattedID'),
                                        me.getSetting('useTShirt')?me._voteSelected.size: me._voteSelected.value)});
                                    me._UC.postedVote(me._storySelected);
                                }
                                else {
                                    Rally.ui.notify.Notifier.showWarning({message: 'Failed to post vote. Please retry'});
                                }
                            }
                        });
                    }
                });
            }
        },
        addartefact: function(story) {
            this._UC.addStory(story);
            this._GC.addStory(story);
        },
        removeartefact: function(story) {
            this._UC.delStory(story);
            this._GC.delStory(story);
        }
    },

    _voteSelected: null,
    _storySelected: null,

    _reloadGame: function() {
        /** Clear out existing data and settings 
         * We will need to refetch the config from the project 
         * */
        this._extraArtefacts = [];
        this._kickOff();
    },

    _iAmModerator: function() {
        return this.getContext().getUser().ObjectID === this._GC.getModerator().get('ObjectID');
    },

    _setUpUserScreen: function() {
        //Check for whether we are the moderator
        var iAmMod = this._iAmModerator();

        if (iAmMod) {
            this.modPage = this._MC.restart(true);
            this._MC.addSwitch();
            this.modPage.show();
            this.userPage = this._UC.restart(false);
            this._UC.addSwitch();
            this.userPage.hide();
            var noCompilerMessage = this._GC.getConfigValue('allowIterationSelector')? this._MC.enableIterationButton():this._MC.disableIterationButton();
        }
        else {
            this.userPage = this._UC.restart(false);
            this.userPage.show();
        }
        if (iAmMod) {
            this._sendArtefacts(this._MC);
        }
        this._sendArtefacts(this._UC);        
    },

    _sendArtefacts: function( target ) {
        if (this._extraArtefacts) {
            _.each(this._extraArtefacts, function (artefact) {
                target.addStory(artefact);
            });
        }
        if ( this._artefactStore) {
            target.loadStories(this._artefactStore.getRecords());
        }
    },

    _getStoryStore: function(filters) {
        var me = this;
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.artifact.Store',{
            models: me._GC.getConfigValue('artefactTypes'),
            context: this.getContext().getDataContext(),
            autoLoad: true,
            pageSize: storyFetchLimit,
            limit: storyFetchLimit,
            sorters: [
                {
                    property: 'DragAndDropRank',
                    dir: 'DESC'
                }

            ],
            fetch: ['FormattedID','TargetDate', 'Description', 'Discussion', 'LatestDiscussionAgeInMinutes','LastUpdateDate', 'Name', 'State', 'ScheduleState', 'Owner', 'PlanEstimate'],
            filters: filters,
            listeners: {
                load: function(store, records, success) {
                    if (success) {
                        storeLoadTime = new Date();
                        Rally.ui.notify.Notifier.show({message: Ext.String.format("Loaded {0} stories", records.length)});
                        deferred.resolve(store);
                    }else {
                        Rally.ui.notify.Notifier.showWarning({message: "No stories found in this iteration/project node"});
                        deferred.reject(null);
                    }
                },
                scope: me
            }
        });
        return deferred.promise;
    },

    _kickOff: function() {
        var me = this;
        /** When we come here, everything should be in place to start a new game
         * Now fetch the User Stories - with the option of only those not sized yet
         */
        me._IC.getCurrentIteration().then({
            success: function(iteration) {
                var filters = [];

                /** If the config has a Story Filter string, use that as well
                 * 
                 */
                var storyFilter = me._GC.getConfigValue('storyFilter');
                if (storyFilter) {
                    filters.push(Rally.data.wsapi.Filter.fromQueryString(storyFilter));
                }

                if (me._GC.getConfigValue('allowIterationSelector')) {
                    
                //     filters.push( Rally.data.wsapi.Filter.or(
                //     [
                //         {
                //             property: 'PlanEstimate',
                //             operator: '=',
                //             value: null
                //         },
                //         {
                //             property: 'PlanEstimate',
                //             operator: '=',
                //             value: 0
                //         }
                //     ]));
                // }
                // else {
                    filters.push({
                        property: 'Iteration',
                        value: iteration
                    });
                }
                filters = Rally.data.wsapi.Filter.and(filters) || [];
                var ffuncs = [];
                ffuncs.push(me._getStoryStore(filters));
                ffuncs.push(me._getExtraStories());
                Deft.Promise.all(ffuncs).then ({
                    success: function(results) {
                        me._artefactStore = results[0];
                        me._extraArtefacts = results[1];
                    },
                    failure: function(e) {
                        console.log("Fatal failure to load stories. Clean out the project config and start again", e);
                    }
                }).always( function() {
                    me._setUpUserScreen();
                });
            },
            failure: function(e) {
                console.log("Didn't find a 'current' iteration", e);
            }
        });

    },

    _getExtraStories: function() {
        var deferred = Ext.create('Deft.Deferred');
        if (this._GC.getConfigValue('extraStories').length){
            Ext.create('Rally.data.wsapi.artifact.Store',{
                models: this._GC.getConfigValue('artefactTypes'),
                context: this.getContext().getDataContext(),
                autoLoad: true,
                pageSize: storyFetchLimit,
                limit: storyFetchLimit,
                filters: [
                    {
                        property: storyIdField,
                        operator: 'in',
                        value: _.pluck(this._GC.getConfigValue('extraStories'), 'storyOID')
                    }
                ],
                listeners: {
                    load: function(store, records, success) {
                        if (success) { deferred.resolve(records);}
                        else { deferred.reject();}
                    }
                },
                scope: this
            });
        }
        else {
            deferred.resolve([]);
        }
        return deferred.promise;
    },

    _loadGameConfig: function() {
        var me = this;

        /** We need to load up the project specific config now.
         */
         this._UC.useTShirtSizing( this._GC.getConfigValue('useTShirt'));

        if (this._iAmModerator()) {
            this._MC.useTShirtSizing( this._GC.getConfigValue('useTShirt'));
            /* Firstly, we need the team members
            */
            var funcs = [this._loadTeamMembers];
            funcs.push(this._loadExtraUsers);
            
            Deft.Chain.parallel(funcs, me).then({
                success: function( results ) {
                    //Add the team members
                    _.each(results[0], function(member) {
                        console.log('Adding user: ',member);
                        me._MC.addUser(member);
                    });
                    //Add the extra users
                    _.each(results[1], function(member) {
                        console.log('Adding user: ',member);
                        me._MC.addExtraUser(member);
                        me._GC.addExtraUser(member);
                    });
                },
                failure: function ( error) {
                    Rally.ui.nofity.Notifier.showError({message: error});
                }
            }).always( function(results) {   
                me._kickOff();
            });
        }
        else {
            me._kickOff();
        }

    },

    _loadExtraUsers: function() {
        var deferred = Ext.create('Deft.Deferred');
        var users = this._GC.getConfigValue('extraUsers') || [];
        if (!users.length) {
            deferred.resolve([]);
            return deferred.promise;
        }

        var filters = [
            {
                property: 'Disabled',
                value: false
            },
            {
                    property: userIdField,
                    operator: 'in',
                    value: _.pluck(users, 'userOID')
            }
        ];

        Ext.create('Rally.data.wsapi.Store', {
            model: 'User',
            fetch: [userIdField, 'UserName', 'DisplayName'],
            autoLoad: true,
            filters:filters,
            listeners: {
                load: function( store, records, success) {
                    if (success === true) {
                        Rally.ui.notify.Notifier.show({ message: "Extra Users loaded"});
                        deferred.resolve(records);
                    }
                    else {
                        console.log("Extra Users unavailable");
                        deferred.reject("Extra Users unavailable");
                    }
                },
                scope: this
            }
        });
        return deferred.promise;
    },

    _loadTeamMembers: function() {
        var deferred = Ext.create('Deft.Deferred');
        var record = this.projectStore.getRecords()[0];
        if ( record.get('TeamMembers').Count > 0) {
            record.getCollection('TeamMembers').load( {
                fetch: [userIdField, 'UserName', 'DisplayName'],
                filters: [
                    {
                        property: 'Disabled',
                        value: false
                    }
                ],
                callback: function( members, operation, success) {
                    //Add all the team members to the GameConfig
                    if (success === true) {
                        Rally.ui.notify.Notifier.show({ message: "Team members loaded"});
                        deferred.resolve(members);
                    }
                    else {
                        console.log("Team members field unavailable");
                        deferred.reject("Team members field unavailable");
                    }
                },
                scope: this
            });
        }
        else {
            Rally.ui.notify.Notifier.showWarning({ message: "Team members not configured"});
            deferred.reject(null,'No Team Members');
        }
        return deferred.promise;
    },

    launch: function () {
        var me = this;
        me._GC = Ext.create('Niks.Apps.PokerGameConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        //Users voting panel
        me._UC = Ext.create('Niks.Apps.PokerUserConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        //Moderators control panel
        me._MC = Ext.create('Niks.Apps.PokerUserConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        me._IC = Ext.create('Niks.Apps.PokerIterationConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        Rally.data.ModelFactory.getModels({
            types: ['UserStory', 'Defect'],
            context: me.getContext().getDataContext(),
            success: function(models) {
                me._GC.setModels(models);
                me._startGame();            
            },
            scope: me
        });

    },

    _startGame: function() {
        var me = this;

        //Check for required fields in this project node

        //Create config page and then pull config from project node if exists. If not, create.
        //If not config already, ask the user if they are to be the Moderator for this.

        /** Set up a timer that reads the config every 1sec so that we pull changes from other users
         * 
         */

        this._checkProjectFieldConfig().then( {
            success: function() {   //Just need to get the store next
                this._getProjectConfig().then({
                    success: function(projConfig) {
                        if (projConfig.hasOwnProperty("moderatorID")){
                            // Ready to go
                            //get the moderator from the saved config ID and give it to the gameConfig to fetch the full user
                            me._GC.setModeratorFromId(projConfig.moderatorID). then ({
                                success: function() {
                                    me._loadGameConfig();
                                },
                                failure: function() {
                                    console.log('Failed to set moderator from ID');
                                }
                            });
                        }
                        else {
                            //Set up new config
                            Ext.create('Rally.ui.dialog.ConfirmDialog', {
                                title: "New Config",
                                message: "Are you moderator for this session?",
                                listeners: {
                                    confirm: function() {
                                        //Set user up as moderator
                                        me._GC.setModeratorFromId( me.getContext().getUser()[userIdField]).then({
                                            success: function() {
                                                me._saveProjectConfig().then({
                                                    success: function() {
                                                        /** Config saved and we are ready to go */
                                                        me._loadGameConfig();
                                                    },
                                                    failure: function(e) {
                                                        console.log("Failed to save project config",e);
                                                    },
                                                    scope: me
                                                });
                                            }
                                        });
                                    }
                                }
                            });
                        }
                    },
                    failure: function(e) {
                        Rally.ui.notify.Notifier.showWarning({ message: e});
                        console.log(e);
                    },
                    scope: me
                });
            },
            failure: function(e) {
                Rally.ui.notify.Notifier.showWarning({ message: e});
                console.log(e);
            },
            scope: me
        });

    },

    _createStoryBrowser: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    _createUserMenu: function() {
        /** Each user must have a way to save and restore their current settings/layout */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    _createLeadMenu: function() {
        /** Lead menu must have access to the config page */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    /** Make sure that the system is set up the way we need */
    _checkProjectFieldConfig: function() {
        var me = this;
        //Check field PlanningConfig exists on project model
        var deferred = Ext.create("Deft.Deferred");

        Rally.data.ModelFactory.getModel({
            type: "Project",
            fetch: true,
            success: function(model) {
                //Add any prechecks here
                if (model.hasField(me.configFieldName) && (model.getField(me.configFieldName).type.type === 'string') ) {
                    deferred.resolve(model);
                } else {
                    //Here, we need to ask if they want to set up the new field (need to be workspace admin)
                    deferred.reject("Correct Config on Project artefact not available");
                }
            },
            failure: function() {
                //Shouldn't happen unless Rally is down
                deferred.reject("Failed to get Project Model");
            }
        });
        return deferred.promise;
    },

    /** As the game progresses, we need to save the state of the game. 
     * We will need to do retries due to concurrency errors that we might get with a number
     * of people trying to update the same field on the Project.
     * 
     * We also will need to be able to reload the last config to get back to where we were 
     * in the game before, if there is ever any issues (browser crash, network error, etc., etc.)
     *  For this, we should put a "refresh" button on the top menu bar
    */
    
    _getProjectConfig: function() {   /** parameter provided is Project Model, but not the actual data */
        var me = this;
        var deferred = Ext.create("Deft.Deferred");
        /** 
         * The current context should contain the Project record that we are currently at. 
         * We could change this to be a project picker if that becomes a useful feature.
         * Even if we update the Project field, then the environment keeps that handily local.
        */
        var project = this.getContext().getProject();
        me.projectStore = Ext.create( 'Rally.data.wsapi.Store', {
            model: 'Project',
            filters: [{
                property: 'ObjectID',
                value: project.ObjectID
            }],
            autoLoad: true,
            fetch: true,
            listeners: {
                load: function(store, records) {
                    me._GC.initialiseConfig(records[0].get(this.configFieldName));
                    me._UC.setConfig(me._GC.getNamedConfig(userConfigName)); 
                    me._MC.setConfig(me._GC.getNamedConfig(userConfigName)); 
                    me._IC.setConfig(me._GC.getNamedConfig(iterConfigName));
                    var currentConfig = me._GC.getNamedConfig(mainConfigName);
                    deferred.resolve(currentConfig);
                },
                scope: me
            }
        });

        return deferred.promise;
    },

    _failedSave: 0,

    /** Save the current config */
    _saveProjectConfig: function() {
        var me = this;
        this._GC.updateNamedConfig(iterConfigName, this._IC.getConfig());
        this._GC.updateNamedConfig(userConfigName, this._MC.getConfig());

        var deferred = Ext.create("Deft.Deferred");
        var currentConfig = this._GC.getGameConfig();

        var record = this.projectStore.getRecords()[0];
        record.set(this.configFieldName, currentConfig);
        record.save({
            success: function() {
                this._failedSave = 0;
                Rally.ui.notify.Notifier.show({ message: "Config Saved to Project"});
                deferred.resolve(currentConfig);
            },
            failure: function() {
                deferred.reject("Failed to save Project Config");
            },
            scope: me
        });
        return deferred.promise;
    },

    _checkConfigChange: function(newConfig) {
        console.log(newConfig);
    },

    //Create and hide the config page
    _createConfigPage: function() {
        /** Config page must have:
         * 1. Moderator Chooser
         * 2. Team member list - enables for this session
         * 3. Timer countdown duration
         * 4. Iteration for this session
         */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },

    /** Make the main pages that the game players need
     * 
     */
    _createUserPage: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },

    _createLeadPage: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },
});

                /** Event Passing */
const modChange = 'moderatorchanged';
const configChange = 'configchanged';
const configSave = 'configsaver';   //Save but don't change this game

/** Configuration naming  */
const mainConfigName = 'MainConfig';
const userConfigName = 'UserConfig';
const iterConfigName = 'IterConfig';

/* Display card  */

const cardWidth = 400;
const cardHeight = 300;
const cardMargin = 10;
const cardSizeField = 'PlanEstimate';
const cardIdField = 'FormattedID';

/** Configuration utils */

const configSplitter1 = '^';
const configSplitter2 = '|';

/* Game numbers */

const votingTime = '00:10';
const userIdField = "ObjectID";
const storyIdField = "ObjectID";
const storyFetchLimit = 50;

/* Poker 'post' types */

const pokerMsg = 
{ 
    votePosted: 'POKER_VOTE_POSTED',
};

const valueSeries = [
        { 
            size: 'XS',
            value: 1,
        },{ 
            size: 'S',
            value: 2,
        },{ 
            size: 'M',
            value: 3,
        },{ 
            size: 'L',
            value: 5,
        },{ 
            size: 'XL',
            value: 8,
        },{ 
            size: 'XXL',
            value: 13,
        },{ 
            size: 'XXXL',
            value: 20,
        }, { 
            size: 'Too Big',
            value: 40,
        }
    ];
                Ext.define('Niks.Apps.Panel', {

    bubbleEvents: [],

    constructor: function(config) {
        this.users = [];
        //this.callParent(arguments);
        Ext.applyIf(this, config);
    },

    getPanel: function(param) {
        return this.configPanel || this._createPanel(param);
    },

    showPanel: function() {
        this.getPanel().show();
    },

    hidePanel: function() {
        this.getPanel().hide();
    },

    destroyPanel: function() {
        if (this.configPanel) {
            this.getPanel().destroy();
            this.configPanel = null;
        }
    },



});

                
Ext.define('Niks.Apps.PokerGameConfig', {
    extend: Niks.Apps.Panel,
    id: mainConfigName+'Panel',
    /** Each interation might have different config
    iterationConfig: {}, 
    */
   /**
    mainConfig: {
        activeStory: null,
        moderatorID: null,
        allowIterationSelector: false,
    },
     */
    /** 
    userConfig: {}, //Contains 'active' as well as other layout info for this game 
     */

    userIDs: [],            /** Only contains the reference to the user only so that we can get info from UserConfig */
    moderatorUser: null,    /** Full object for the moderator */
    models: [],

    setModels: function(models) {
        this.models = models;
    },

    /** We know of three config types right now: MainConfig, IterationConfig, UserConfig */
    initialiseConfig: function(fieldText) {
        this[mainConfigName] = this._decodeConfig(mainConfigName, fieldText);
        this[userConfigName] = this._decodeConfig(userConfigName, fieldText);
        this[iterConfigName] = this._decodeConfig(iterConfigName, fieldText);
        if (!this[mainConfigName].votingTime) {
            this[mainConfigName].votingTime = votingTime;
        }
        
        if ((!this[mainConfigName].artefactTypes) || !this[mainConfigName].artefactTypes.length){
            this[mainConfigName].artefactTypes = ['UserStory', 'Defect'];
        }
        this[mainConfigName].extraUsers = this[mainConfigName].extraUsers || [];
        this[mainConfigName].extraStories = this[mainConfigName].extraStories || [];
    },

    getNamedConfig: function(name) {
        return this[name] || {};
    },

    //Send in an object 
    updateNamedConfig: function(name, config) {
        this[name] = config;
    },

    _decodeConfig: function(requiredType, fieldText) {

        if ((fieldText === undefined) || ( fieldText.length === 0)) {
            return {};
        }
        var msgs = fieldText.split(configSplitter1);
        var configs = {};
        _.each(msgs, function(msg) {
            var splitMsg = msg.split(configSplitter2);
            if (splitMsg[0].length) {
                configs[splitMsg[0]] = splitMsg[1];
            }
        });
        return JSON.parse(configs[requiredType] || "{}");
    },

    addStory: function(story) {   //Passed in a user record
        if ( _.find(  this[mainConfigName].extraStories, function(existing) {
                return existing.storyOID === story.get(storyIdField);
            })
            ) {
                console.log("Adding existing story - ignoring!");
            
        } else {
            this[mainConfigName].extraStories.push({
                storyOID: story.get(storyIdField),
                storyFID: story.get('FormattedID'),
                storyName: story.get('Name')
            });
            this._updateCurrentStoryList();
        }
    },
    
    delStory: function( story) {
        var storedStory = _.find( this[mainConfigName].extraStories, {storyOID: story.get(storyIdField)});
        if ( !storedStory) {
            console.log("Removing non-existent story - ignoring!");
        } else {
            this[mainConfigName].extraStories = _.without(this[mainConfigName].extraStories, storedStory);
            this._updateCurrentStoryList();
        }
        
    },
    addUser: function(user) {   //Passed in a user record
        if ( _.find( this.userIDs, {userOID: user.get(userIdField)})) {
            console.log("Adding existing member - ignoring!");
        } else {
            this.userIDs.push(user[userIdField]);
        }
    },

    addExtraUser: function( user) {

        if ( _.find( this[mainConfigName].extraUsers, {userOID: user.get(userIdField)})) {
            console.log("Adding existing member - ignoring!");
        } else {
            this[mainConfigName].extraUsers.push({ 
                userOID: user.get(userIdField),
                displayName: user.get('_refObjectName')
            });
            this._updateCurrentUserList();
        }

    },

    removeExtraUser: function( user) {
        var storedUser = _.find( this[mainConfigName].extraUsers, {userOID: user.get(userIdField)});
        if ( !storedUser) {
            console.log("Removing non-existent member - ignoring!");
        } else {
            this[mainConfigName].extraUsers = _.without(this[mainConfigName].extraUsers, storedUser);
            this._updateCurrentUserList();
        }
        
    },

    getModerator: function() {
        if (this.moderatorUser) {
            return this.moderatorUser;
        }
        else {
            return null;   //Be specific about a null.
        }
    },

    setModerator: function(user) {
        console.log('mod set to:',user);
        this[mainConfigName].moderatorID = user.get(userIdField);
        this.moderatorUser = user;
    },

    setModeratorFromId: function(id) {
        var me = this;
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            model: 'User',
            autoLoad: true,
            filters: [
                {
                    property: userIdField,
                    value: id
                }
            ],
            listeners: {
                load: function(store, records, success) {
                    if (success) {
                        me.setModerator(records[0]);
                        deferred.resolve(records[0]);
                    }
                    else {
                        deferred.reject();
                    }
                }
            }
        });
        return deferred.promise;
    },

    getConfigValue: function(fieldName) {
        return this[mainConfigName][fieldName];
    },

    _encodeMsg: function(msgType, msgText) {
        return configSplitter1 + msgType + configSplitter2 + msgText;
//        return configSplitter + msgType + "," + window.btoa(msgText);
    },

    _decodeMsg: function(msgType, msgText) {
        return msgText.split(configSplitter2).pop();
    },

    /* Gameconfig is the thing that is stored to the Project field. Must not be more than 32768 chars */
    getGameConfig: function() {
        return  this._encodeMsg(mainConfigName, JSON.stringify(this[mainConfigName])) +
                this._encodeMsg(userConfigName, JSON.stringify(this[userConfigName]))+
                this._encodeMsg(iterConfigName, JSON.stringify(this[iterConfigName]));
    },

    _getCurrentUserList: function() {
        var text = '';
        _.each (this.getConfigValue('extraUsers'), function (user) {
            text += user.displayName+", ";
        });
        return text;
    },

    _getCurrentStoryList: function() {
        var text = '';
        _.each (this.getConfigValue('extraStories'), function (story) {
            text += story.storyFID+", ";
        });
        return text;
    },

    _updateCurrentUserList: function() {
        this.getPanel().down('#extrauserlist').setValue(this._getCurrentUserList());
        this.app.fireEvent(configChange);
    },
    _updateCurrentStoryList: function() {
        this.getPanel().down('#extrastorylist').setValue(this._getCurrentStoryList());
        this.app.fireEvent(configChange);
    },

    _createPanel: function() {
        var me = this;
        var panel = Ext.create('Ext.panel.Panel', {
//        var panel = Ext.create('Ext.container.Container', {
            floating: true,
            draggable: true,
            width: 540,
            baseCls: 'configPanel',
            hidden: true,
            closable: true,
            closeAction: 'hide',
        });
        panel.add( {
            xtype: 'container',
            layout: 'vbox',
            style: {
                border: 'none'
            },
            margin: '5 0 5 20',
            items: [
                {
                    xtype: 'text',
                    text: 'Game Settings:',
                    cls: 'configPanelTitle'
                },
                {
                    xtype: 'field',
                    id: 'curMod',
                    fieldLabel: 'Current Moderator',
                    labelWidth: 180,
                    width: 460,
                    margin: '10 0 5 20',
                    baseBodyCls: 'textfield',
                    readOnly: true,
                    value: me.moderatorUser? me.moderatorUser.get('UserName'): 'Not Set'

                },
                {
                    xtype: 'rallyusercombobox',
                    id: 'modChooser',
                    fieldLabel: 'Change Moderator To',
                    valueField: userIdField,
                    labelWidth: 180,
                    width: 460,
                    margin: '0 0 5 20',
                    autoSelect: false,
                    listeners: {
                        //Setvalue fires when the thing is first set up with a null value.
                        select: function(entry) {
                            if (entry.value !== null) {
                                me.setModerator(entry.lastSelection[0]);
                                panel.down('#curMod').setValue(me.moderatorUser.get('UserName'));
                                Ext.create('Rally.ui.dialog.ConfirmDialog', {
                                        title: "New Moderator",
                                        message: "Restart session?",
                                        listeners: {
                                            confirm: function() {
                                                //Set user up as moderator
                                                me.app.fireEvent(configChange);
                                                me.hidePanel();
                                            }
                                        }
                                    }
                                );
                            }
                        },
                    }
                },
                {
                    xtype: 'rallycheckboxfield',
                    fieldLabel: "Enable Iteration Selector",
                    id: 'allowIterationSelector',
                    value: me[mainConfigName].allowIterationSelector,
                    labelWidth: 180,
                    margin: '0 0 5 20',
                    listeners: {
                        change: function( tickbox, newV, oldV, opts) {
                            me[mainConfigName].allowIterationSelector = newV;
                            me.app.fireEvent(configChange);
                        }
                    }
                },
                {
                    xtype: 'rallycheckboxfield',
                    fieldLabel: "Use T-Shirt sizing",
                    id: 'useTShirt',
                    value: me[mainConfigName].useTShirt,
                    labelWidth: 180,
                    margin: '0 0 5 20',
                    listeners: {
                        change: function( tickbox, newV, oldV, opts) {
                            me[mainConfigName].useTShirt = newV;                   
                            me[userConfigName].useTShirt = newV;
                            me.app.fireEvent(configChange);
                        }
                    }
                },
                {
                    xtype: 'textfield',
                    baseCls: 'timerText',
                    fieldLabel: 'Voting Time (min:sec)',
                    labelWidth: 180,
                    margin: '0 0 5 20',
                    value: me[mainConfigName].votingTime  || votingTime,
                    validator: function(value) {
                        if (Ext.Date.parse(value, "i:s") !== undefined) {
                            me[mainConfigName].votingTime = value;
                            me.app.fireEvent(configSave);   //Save but don't change this game
                            return true;
                        }
                        return false;
                    }
                }
            ]            
        });

        panel.add( {
            xtype: 'container',
            layout: 'vbox',
            margin: '5 0 5 20',
            items: [
                {
                    xtype: 'text',
                    text: 'Artefact Filtering:',
                    cls: 'configPanelTitle'
                },
                {
                    xtype: 'container',

                    layout: 'hbox',
                    items: [
                        {
                            xtype: 'rallycheckboxfield',
                            itemId: 'selectStories',
                            fieldLabel: 'Stories',
                            labelWidth: 80,
                            labelAlign: 'right',
                            listeners: {
                                change: function(item, setting) {
                                    if (!setting) {
                                        me[mainConfigName].artefactTypes = _.without(me[mainConfigName].artefactTypes, 'UserStory');
                                        if ( me.getPanel().down('#selectDefects').getValue() === false ){
                                            me.getPanel().down('#selectDefects').setValue(true);
                                        }
                                    }
                                    else {
                                        me[mainConfigName].artefactTypes = _.union(me[mainConfigName].artefactTypes, ['UserStory']);
                                    }
                                    me.app.fireEvent(configChange);

                                }
                            },
                            value: _.indexOf(me[mainConfigName].artefactTypes, 'UserStory') >= 0
                        },
                        {
                            xtype: 'rallycheckboxfield',
                            fieldLabel: 'Defects',
                            labelWidth: 80,
                            labelAlign: 'right',
                            itemId: 'selectDefects',
                            margin: 0,
                            listeners: {
                                change: function(item, setting) {
                                    if (!setting) {
                                        me[mainConfigName].artefactTypes = _.without(me[mainConfigName].artefactTypes, 'Defect');
                                        if ( me.getPanel().down('#selectStories').getValue() === false ){
                                            me.getPanel().down('#selectStories').setValue(true);
                                        }

                                    }
                                    else {
                                        me[mainConfigName].artefactTypes = _.union(me[mainConfigName].artefactTypes, ['Defect']);
                                    }
                                    me.app.fireEvent(configChange);
                                }
                            },
                            value: _.indexOf(me[mainConfigName].artefactTypes, 'Defect') >= 0

                        }
                    ]
                },
                {
                    xtype: 'textarea',
                    fieldLabel: 'Query Filter',
                    name: 'query',
                    cls: 'query-field',
                    labelAlign: 'top',
                    width: 460,
                    value: me[mainConfigName].storyFilter,
                    margin: '0 20 5 20',
                    validateOnBlur: true,
                    validateOnChange: false,
                    validator: function(value) {
                        try {
                            if (value) {
                                Rally.data.wsapi.Filter.fromQueryString(value);
                            }
                            me[mainConfigName].storyFilter = value;
                            me.app.fireEvent(configChange);
                            return true;
                        } catch (e) {
                            return e.message;
                        }
                    }      
                }
            ]  
        });

        panel.add ( {
            xtype: 'container',
            layout: 'vbox',
            width: '100%',
            margin: '5 0 5 20',

            items: [
                {
                    xtype: 'text',
                    text: 'Additional Voters:',
                    cls: 'configPanelTitle'
                },
                {
                    xtype: 'container',
            
                    layout: 'hbox',
                    items: [
                        
                        {
                            fieldLabel: 'Choose',
                            margin: '5 0 5 20',
                            labelWidth: 40,
                            width: 300,
                            xtype: 'rallyusersearchcombobox',
                            itemId: 'usersearchbox',
                            storeConfig: {
                                fetch: ['_ref', '_refObjectName', userIdField, 'UserName', 'DisplayName']
                            },
                            listeners: {
                                select: function(selector, user) {
                                    panel.down('#addUserButton').enable();
                                    panel.down('#delUserButton').enable();
                                }
                            }
                        },
                        {
                            xtype: 'rallybutton',
                            text: 'Add',
                            itemId: 'addUserButton',
                            disabled: true,
                            width: 70,
                            margin: 5,
                            handler: function() {
                                me.app.fireEvent('adduser', panel.down('#usersearchbox').getRecord());
                            }
                        },
                        {
                            xtype: 'rallybutton',
                            text: 'Remove',
                            itemId: 'delUserButton',
                            width: 70,
                            disabled: true,
                            margin: '5 0 5 0',
                            handler: function() {
                                me.app.fireEvent('removeuser', panel.down('#usersearchbox').getRecord());
                            }
                        }
                    ]
                },
                {
                    xtype: 'textarea',
                    fieldLabel: 'Additional User List',
                    itemId: 'extrauserlist',
                    labelAlign: 'top',
                    width: 460,
                    value: me._getCurrentUserList(),
                    margin: '0 0 5 20',
                    readOnly: true   
                }
            ]
        });

        panel.add( {
            xtype: 'container',
            layout: 'vbox',
            width: '100%',
            margin: '5 0 5 18',
            items: [
                {
                    xtype: 'text',
                    text: 'Priority Artefacts:',
                    cls: 'configPanelTitle'
                },
                {
                    xtype: 'container',
                    layout: 'hbox',
                    items: [
                        {
                            margin: '5 0 5 20',
                            fieldLabel: 'Choose',
                            labelWidth: 40,
                            width: 300,
                            xtype: 'rallyartifactsearchcombobox',
                            itemId: 'searchbox',
                            storeConfig: {
                                models: ['UserStory', 'Defect'],
                                fetch: true
                            },
                            listeners: {
                                select: function(selector, artefact) {
                                    panel.down('#addAtftButton').enable();
                                    panel.down('#delAtftButton').enable();
                                }
                            }
                        },
                        {
                            xtype: 'rallybutton',
                            text: 'Add',
                            itemId: 'addAtftButton',
                            disabled: true,
                            width: 70,
                            margin: 5,
                            handler: function() {
                                me.app.fireEvent('addartefact', panel.down('#searchbox').getRecord());
                            }
                        },
                        {
                            xtype: 'rallybutton',
                            text: 'Remove',
                            itemId: 'delAtftButton',
                            width: 70,
                            disabled: true,
                            margin: '5 0 5 0',
                            handler: function() {
                                me.app.fireEvent('removeartefact', panel.down('#searchbox').getRecord());
                            }
                        }
                    ]
                },{
                    xtype: 'rallyaddnew',
                    margin: '5 0 5 20',
                    recordTypes: ['User Story', 'Defect'],
                    ignoredRequiredFields: ['Name', 'ScheduleState', 'Project', 'Owner', 'FlowState'],
                    listeners: {
                        create: function(addnew, record) {
                            Rally.ui.notify.Notifier.show(Ext.String.format('Added {0}: {1}',
                                record.get('FormattedID'),
                                record.get('Name')
                            ));
                            me.app.fireEvent('addartefact', record);
                        }
                    }
                },{
                    xtype: 'textarea',
                    fieldLabel: 'Additional Artefact List',
                    itemId: 'extrastorylist',
                    labelAlign: 'top',
                    width: 460,
                    value: me._getCurrentStoryList(),
                    margin: '5 0 5 20',
                    readOnly: true   
                }
            ]
        });
        this.configPanel = panel;
        return panel;
    },
});
                Ext.define('Niks.Apps.PokerCard', {
    extend: Ext.panel.Panel,
    margin: cardMargin,
    layout: {
        type: 'vbox',
        align: 'left'
    },
    autoScroll: true,
    config: {
        story: null,
        voteSize: null
    },
    applyVoteSize: function(size) {
        this.voteSize = size;
        var me = this;
        var btn = Ext.create('Rally.ui.Button',{
            margin: 10,
            disabled: true,
            text: (size.tshirt? size.size: size.value).toString(),
            cls: 'buttontext',
            width: this.width - 22,
            height: this.height - 22,
            handler : function() {
                this.up('#pokerApp').fireEvent('voteselected',me.voteSize);
            }
        });
        this.add( btn);
    },

    postedVote: function() {
        this.voted = this.vote;
        this.setVoteString();
    },

    setVoteString: function (vote) {
        if (vote && (vote !== this.vote)) { 
            this.vote = vote;
        }
        if ( (vote && (vote !== this.vote)) ||
            (this.vote !== this.voted)) 
        {
            this.tf.removeCls('definedfield');
            this.tf.addCls('erroredfield');
        }
        else {
            this.tf.addCls('definedfield');
            this.tf.removeCls('erroredfield');
        }
        var ls = this.story.get(cardSizeField);
        ls = (ls === null)?(ls === 0?'set to zero':'not set'):ls.toString();
        this.tf.update(Ext.String.format('Current Size: {0} {1} {2}',
            ls, 
            this.vote?" - You chose: "+(this.vote.tshirt? this.vote.size: this.vote.value):'',
            this.voted?' and have voted: '+(this.voted.tshirt? this.voted.size: this.voted.value) :''));
    },

    applyStory: function(story) {
        var me = this;
        this.story = story;

        this.tf = Ext.create('Ext.form.field.Text', {
                xtype: 'textfield',
                itemId: 'sizeText'+story.get(cardIdField),
                width: cardWidth - 30,
                margin: '5 0 5 10',
                cls: 'definedfield'
            });
        this.add( this.tf );
        this.setVoteString();

        var description = story.get('Description');
        description = description.length?description:'<p>Description field Empty</p><p><b>Please go to Artefact and enter a Description of the Required Effort</b></p>';
        var taf = Ext.create('Ext.form.Label',{
                margin: cardMargin,
                forId: 'sizeText'+story.get(cardIdField),
                width: cardWidth - 40,
                grow: true,
                hideLabel: true,
                readOnly: true,
                autoScroll: true,
                html: description
            }
        );
        this.add(taf);

        this.getEl().on('click', function(evt, target) {
            if (target.nodeName === "A") {
                return;
            }
            this.up('#pokerApp').fireEvent('cardselected',this);
        }, me);
    },
});

                /** Something to hold the current config of the user during this session
 * 
 */

Ext.define('Niks.Apps.PokerUserConfig', {
    extend: Niks.Apps.Panel,
    
    getConfig: function() {
        return this[userConfigName];
    },

    setConfig: function(config) {
        this[userConfigName] = config;
    },

    
    /* This is called from something that has got a Store record not just a model */
    removeUser: function(userRecord) {
        /** Check if the user is in the array. If not, then add */
        var existingUser = _.find(this.users, function(user) {
            if (userRecord.get(userIdField) === user.get(userIdField)) {
                return true;
            }
        });
        if (existingUser !== undefined){
            this.users = _.filter(this.users, function(user) {
                return userRecord.get(userIdField) !== user.get(userIdField);
            });
        }
    },


    /* This is called from something that has got a Store record not just a model */
    addUser: function(userRecord) {
        /** Check if the user is in the array. If not, then add */
        if (!_.find(this.users, function(user) {
            if (userRecord.get('ObjectID') === user.get(userIdField)) {
                return true;
            }
        })){
            this.users.push(userRecord);
        }
    },


    removeExtraUser: function(userRecord){
        this.removeUser(userRecord);
        this._setVotes([]); //Redo the voting panel - clears out all votes unfortunately.

    },

    addExtraUser: function(user) {
        this.addUser(user);
        this._setVotes([]); //Redo the voting panel - clears out all votes unfortunately.
    },

    restart: function(iAmMod) {
        this.stories = [];
        this.destroyPanel();
        var page = this.getPanel(iAmMod);
        this.cardSelected = null;
        if (iAmMod) {
            this._doVotes();
        }
        return page;
    },

    //Stories can come as the form of the records in a store
    loadStories: function( stories ) {
        var me = this;
//        if (me.getPanel().down('#cardspace')) { me.getPanel().down('#cardspace').removeAll(false);}
        _.each(stories, function(story) {
            me.addStory(story);
        });
    },

    addStory: function(story) {
        //If story already in the list, return false and do nothing else
        if ( _.find(this.stories, function( existing) {
            if ( existing.story.get(cardIdField) === story.get(cardIdField)) {
                return true;
            }
        })) {
            return false;
        }
        var card = this._createCard(story);
        var cs = this.getPanel().down('#cardspace');
        cs.add(card);
        card.setStory(story);
        this.stories.push( card );
        return true;
    },

    delStory: function(story) {
        var card = this.getPanel().down('#card-'+story.get(cardIdField));
        if ( card ) {
            card.destroy();        
            this.stories = _.filter(this.stories, function(existing) {
                return ( existing.story.get(cardIdField) !== story.get(cardIdField));
            });
            return true;
        }
        return false;
    },

    _createCard: function(story) {
        return  Ext.create('Niks.Apps.PokerCard', {
            title: Ext.String.format(
                '<table><tr><td>' +
                '<a target="_blank" href={1}>{0} </a>' + 
                '<a target="_blank" href={2} class="icon-chat"></a>' +
                '</td><td class="rightAlignField">' +
                '<p class="rightAlignField">{3}</p>' +
                '</td></tr></table>', 
                        story.get(cardIdField), 
                        Rally.nav.Manager.getDetailUrl(story, {subPage: ''}),
                        Rally.nav.Manager.getDetailUrl(story, {subPage: 'discussion'}),
                        story.get('Name')),
            width: cardWidth,
            height: cardHeight,
            itemId: 'card-'+story.get(cardIdField)
        });
    },

    /** Mainconfig comes over from the app so that we can set the time up 
     *  when we are moderator
    */

    selectCard: function(card, mainConfig) {

        //Find our entry in this.stories for chosen card
        var cardSelected = _.find( this.stories, function(storyCard) {
            return card.story.get(cardIdField) === storyCard.story.get(cardIdField);
        });

        if (cardSelected === this.cardSelected) {
                this.cardSelected.removeCls('cardSelected');
                this.cardSelected  = null;
        }
        else {
            cardSelected.addCls('cardSelected');
            if (this.cardSelected)  {
                this.cardSelected.removeCls('cardSelected');
            }
            this.cardSelected = cardSelected;
            return this._setVoting(card, mainConfig);
        }
        this._checkVoteButton();
        return false;
    },

    _checkVoteButton: function() {
        var voteButton =  this.getPanel().down('#voteNow');
         if ( voteButton) {
             if ( this.cardSelected && this.cardSelected.vote) {
                 voteButton.enable();
             }
             else {
                 voteButton.disable();
             }
         }
    },

    _setVoting: function(card, mainConfig) {
        var me = this;
        this.votingCard = card;
        this[mainConfigName] = mainConfig;
        var actions = this.getPanel().down('#actions');
        if (this.userOrModerator) {
            //For the moderator, we need to manage the timer and fetch the votes
            if (this.timerRunning) {
                //Ask to stop and reset timer
                Ext.create('Rally.ui.dialog.ConfirmDialog',{
                    title: 'Cancel current voting',
                    message: "Stop the timer for the current session?",
                    confirmLabel: 'Yes, please',
                    listeners: {
                        confirm: function() {
                            me._stopTimer();
                            me._configureTimer(actions);
                        },
                        scope: me
                    }
                });
            }
            else {

                this._configureTimer(actions);
                return true;
            }
            return false;
        }
        else {
            // Set the votemessage field if we already have chosen on this one.
            var foundStory = _.find(this.stories, function(savedStory) {
                return card.story.get(cardIdField) === savedStory.story.get(cardIdField);
            });
            if ( foundStory  && foundStory.vote) {
                me.setVote(foundStory.vote);
            }
            else {
                me.clearVote();
            }

            /** Enable all the buttons  */
            var ap = this.configPanel.down('#actions');
            if (this.cardSelected) {
                _.each(ap.getChildItemsToDisable(), function(item) { item.enable();});
            } else {
                _.each(ap.getChildItemsToDisable(), function(item) { item.disable();});
                this.getPanel().down('#votemessage').update('Choose an item &rarr;');
            }
            return true;
        }
    },

    postedVote: function(card) {
        var foundStory = _.find(this.stories, function(savedStory) {
            return card.story.get(cardIdField) === savedStory.story.get(cardIdField);
        });
        foundStory.postedVote();
    },

    refreshVotes: function() {
        this._doVotes();
    },

    //Add button to send switchpanel message to app
    addSwitch: function() {
        var me = this;
        this.getPanel().down('#menu').add({
            xtype: 'rallybutton',
            width: 100,
            text: 'Switch View',
            margin: '10 10 0 10',
            handler: function() {
                me.app.fireEvent('switchpanel');
            }
        });
    },

    disableIterationButton: function() {
        this.getPanel().down('#iterationButton').disable();
    },

    enableIterationButton: function() {
        this.getPanel().down('#iterationButton').enable();
    },

    useTShirtSizing: function(tshirt) {
        this[userConfigName].useTShirt = tshirt;
    },

    setVote: function(vote) {
        var me = this;
        var storySelected = _.find( this.stories, function(card) {
            return me.cardSelected.story.get(cardIdField) === card.story.get(cardIdField);
        });
        storySelected.setVoteString(vote);
        this.getPanel().down('#votemessage').update('&larr; Vote '+(vote.tshirt?vote.size:vote.value).toString());
        this._checkVoteButton();
    },

    clearVote: function() {
        this.getPanel().down('#votemessage').update('Choose a vote &darr;');
        this._checkVoteButton();
    },

    _timerRunning: 0,

    _stopTimer: function() {
        this._timerRunning = 0;
    },

    _configureTimer: function(actions) {
        if ((this[mainConfigName] === undefined) || (this[mainConfigName].votingTime === "00:00")) {
            return;
        }
        var bits = this[mainConfigName].votingTime.split(':');   //Shortcut as it should always be 00:00 format
        this._timerRunning = (bits[0] * 60) + bits[1];
        this.configPanel.down('#countdowntimer').setValue(this[mainConfigName].votingTime);
        this.configPanel.down('#countdowntimer').getEl().removeCls('timerfinished');
        this.configPanel.down('#countdowntimer').getEl().removeCls('textBlink');
        this.configPanel.down('#countdowntimer').getEl().addCls('timerreset');


    },

    _revealVotes: false,
    _votes: null,

    _doVotes: function() {
        var me = this;
        me._getVotes().then({
            success: function(results) {
                me._setVotes(results);
            }
        });
    },

    _setNameDiv: function(str) {
        return '<div class ="votename"><b>'+str+'</b></div>';
    },
    _setCastDiv: function(str) {
        return '<div class ="votesize"><b>'+str+'</b></div>';
    },
    _setDateDiv: function(str) {
        return '<div class ="votedate"><b>'+str+'</b></div>';
    },

    _setVotes: function(results) {
        var me = this;
        if (!this.configPanel) { return;}
        if (!results.length) { this._revealVotes = false;}
        var votesPanel = this.configPanel.down('#votespanel');
        votesPanel.removeAll();
         var showHideBtn = this.configPanel.down('#revealvotesbtn');
         if (me._revealVotes === false) {
            showHideBtn.setText('Reveal Votes');
        }
        else {
            showHideBtn.setText('Hide Votes');
        }
        votesPanel.add( {
            html: this._setNameDiv("<u>Team Member</u>")
        });
        votesPanel.add( {
            html: this._setCastDiv("<u>Vote Cast</u>")
        });
        votesPanel.add( {
            html: this._setDateDiv("<u>When</u>")
        });
        
        var votesFound = [];

        _.each(me.users, function(user) {
            var foundUserAnswer = _.find(results, function(result) {
                return result.get('User').ObjectID === user.get('ObjectID');
            });
            var vote = "&nbsp";
            var answer = {};
            var timeAt = "&nbsp";
            if (foundUserAnswer !== undefined) {
                answer = foundUserAnswer.get('Text');
                answer =  JSON.parse(answer.split(pokerMsg.votePosted+':')[1].split('<')[0]);
                votesFound.push(answer);
                vote = this._revealVotes?(answer.tshirt?(answer.size+ ' ('+answer.value+')'):answer.value).toString(): '?';
                timeAt = foundUserAnswer.get('_CreatedAt');
            }
            votesPanel.add( {
                html: this._setNameDiv(user.get('_refObjectName')),
            });
            votesPanel.add( {
                html: this._setCastDiv(vote),
            });
            votesPanel.add( {
                html: this._setDateDiv(timeAt),
            });
            // Put this inside loop so that we don't have to check for null
            this.configPanel.down('#revealvotesbtn').enable();
            
        }, me);

        if ( this._revealVotes) {
            votesPanel.add( {
                html: '<div class="votestext">AVERAGE</div>'
            });
            var votesCount = votesFound.length, votesTotal = _.reduce(votesFound, function(result,vote, key) {
                return {
                    size: 'uk',
                    value: result.value + vote.value
                };
            });
            votesTotal = votesTotal.value;
            
            var nearest =  _.reduce(valueSeries, function(result, value, key) {
                var oldOne = Math.abs(result.value - (votesTotal/(votesCount?votesCount:1)));
                var newOne = Math.abs(value.value - (votesTotal/(votesCount?votesCount:1)));
                return (newOne < oldOne)? value:result;
            });

            votesPanel.add ( {
                html: '<div class="votestext">'+(votesFound.length?((me[userConfigName].useTShirt?(nearest.size+ ' ('+nearest.value+')'):nearest.value)):"-") + '</div>'
            });
            votesPanel.add ( {
                
                html: '<div class="votestext">'+(votesFound.length?(' ('+(votesTotal/(votesCount?votesCount:1)).toFixed(1)+')'): '&nbsp')+'</div>'
            });
        }
        else {
            votesPanel.add ( {
                html: '<div class="votestext">&nbsp</div>'
            });
            votesPanel.add ( {
                html: '<div class="votestext">&nbsp</div>'
            });
            votesPanel.add ( {
                html: '<div class="votestext">&nbsp</div>'
            });

        }

    },

    _getVotes: function() {
        var me = this;
        me._votes = null;
        me._revealVotes = false;

        var deferred = Ext.create('Deft.Deferred');
        if (!this.cardSelected) { 
            //Rally.ui.notify.Notifier.showWarning({message: 'No item selected'});
            deferred.resolve([]);
            return deferred.promise;
        }

        /** Get the discussion posts that are owned by the team members and contain the key string "VOTEPOSTED"
         * Soert by newest to oldest. Search through until you fdind entries for all the users. If not, then signal 
         * that some users have not posted.
         */

        var userFilters = [];
        _.each( this.users, function(user) {
            userFilters.push( {
                property: 'User',
                value: user.get('_ref')
            });
        });

        var filters = [Rally.data.wsapi.Filter.or(userFilters)];

        filters.push(
            {
                property: 'Artifact',
                value: this.cardSelected.story.get('_ref')
            }
        );

        filters.push(
            {
                property: 'Text',
                operator: 'contains',
                value: pokerMsg.votePosted
            }
        );
        Ext.create('Rally.data.wsapi.Store', {
            model: 'ConversationPost',
            filters: Rally.data.wsapi.Filter.and(filters),
            autoLoad: true,
            sorters: [
                {
                    property: 'CreationDate',   //Get this way around so that we can fetch the latest one first
                    direction: 'DESC'
                }
            ],
            listeners: {
                load: function(store, records, success) {
                    if (success){
                        me._votes = records;
                        deferred.resolve(records);
                    }
                    else {
                        deferred.reject();
                    }
                },
                scope: me
            }
        });
        return deferred.promise;

    },

    _countdownTimer: function(me) {
        if (me._timerRunning >0) {
            me._decrementTimer();
            me.configPanel.down('#countdowntimer').getEl().addCls('timerrunning');
            me.configPanel.down('#countdowntimer').getEl().removeCls('timerfinished');
            me.configPanel.down('#countdowntimer').getEl().removeCls('timerreset');
            me._timerRunning -= 1;
            setTimeout(me._countdownTimer, 1000, me);
        } else {
            if (this.cardSelected) {
                // Ext.create('Rally.ui.dialog.ConfirmDialog', {
                //     title: 'Timer Expired',
                //     message: "Refresh Votes?",
                //     confirmLabel: 'Yes, please',
                //     listeners: {
                //         confirm: function() {
                            me.configPanel.down('#countdowntimer').getEl().removeCls('timerrunning');
                            me.configPanel.down('#countdowntimer').getEl().addCls('timerfinished');
                            me.configPanel.down('#countdowntimer').getEl().removeCls('textBlink');
                            me._doVotes();
                        // },
                        // cancel: function() {
                        //     me.configPanel.down('#countdowntimer').getEl().removeCls('timerrunning');
                        //     me.configPanel.down('#countdowntimer').getEl().addCls('timerfinished');
                        //     me.configPanel.down('#countdowntimer').getEl().removeCls('textBlink');

                        // },
                        // scope: me
                    }
//                });
//            }
            me.configPanel.down('#countdowntimer').getEl().addCls('timerfinished');
            me.configPanel.down('#countdowntimer').getEl().addCls('textBlink');

        }

    },
    _decrementTimer: function() {
        var bits = this.configPanel.down('#countdowntimer').getValue().split(':');   //Shortcut as it should always be 00:00 format
        if (bits.length !== 2) { return; }
        var timerNow = ((bits[0] * 60) + bits[1]) ;
        if (timerNow === 0) { return;}
        var timerNext = timerNow - 1;
        var minutes = Math.floor(timerNext/60);
        minutes = (minutes< 10) ? '0'+minutes: minutes.toString();
        var seconds = timerNext%60;
        seconds = (seconds< 10) ? '0'+seconds: seconds.toString();
        this.configPanel.down('#countdowntimer').setValue(minutes+":"+seconds);

    },

    //Singleton that never dies..... hopefully....
    _createPanel: function(userOrModerator) {   //0 = user, !0 = mod
        var me = this;
        this.userOrModerator = userOrModerator;
        var page = me.configPanel = Ext.create('Ext.container.Container', {
            width: '100%',
            hideMode: 'display',
            height: me.app.getHeight(),
            layout: 'hbox',
            itemId: userOrModerator? 'modPage':'userPage',
            items: [
                {
                    xtype: 'container',
                    itemId: 'menu',
                    width: 120,
                    margin: cardMargin,
                    cls:'clearpanel'
                },
                {
                    xtype: 'container',
                    itemId: 'actions',
                    width: 400,
                    cls:'clearpanel',
                },
                {
                    xtype: 'container',
                    itemId: 'cardspaceparent',
                    width: '50%',
                    height: '100%',
                    flex: 1,
                    cls:'clearpanel',
                    autoScroll: true
                }
            ]
        });

        if (userOrModerator) {
            page.down('#actions').add(
                {
                    xtype: 'container',
                    margin: '10 0 0 0',
                    cls: 'userpanel',
                    items: [
                        {
                            xtype: 'textfield',
                            itemId: 'countdowntimer',
//                            width: '100%',
                            height: 50,
                            margin: 10,
                            labelCls: 'cardtext',
                            fieldCls: 'clearpanel timertext timerreset',
                            fieldLabel: 'Countdown Timer',
                            labelAlign: 'left',
                            value: "00:00",
                            readOnly: true,
                            labelWidth: 120,
        //                    margin: '5 0 5 10',
                        },
                        {
                            xtype: 'container',
                            layout: 'hbox',
                            items: [
                                {
                                    xtype: 'rallybutton',
                                    text: 'Start',
                                    margin: 10,
                                    width: 100,
                                    handler: function() {
                                        if ( this.cardSelected === null ){
                                            Rally.ui.notify.Notifier.showWarning({message: 'No story selected'});
                                        }else {
                                            me._countdownTimer(me);
                                        }
                                    }
                                },
                                {
                                    xtype: 'rallybutton',
                                    text: 'Stop',
                                    margin: 10,
                                    width: 100,
                                    handler: function() {
                                        me._timerRunning = 0;
                                    }
                                },
                                {
                                    xtype: 'rallybutton',
                                    text: 'Reset',
                                    width: 100,
                                    margin:10,
                                    handler: function() {
                                        me._configureTimer();
                                    }
                                },

                            ]
                        },
                        {
                            xtype: 'panel',
                            itemId: 'votespanel',

                            width: '100%',
                            bodyCls: 'userpanel',

                            layout: {
                                type: 'table',
                                columns: 3,
                                tdAttrs: {
                                    style: {
                                        textAlign: 'center',
                                    }
                                }
                            },
                            defaults: {
                                bodyStyle: 'border:none'
                            }
                        },
                        {
                            xtype: 'container',
                            layout: 'hbox',
                            items: [
                                {
                                    xtype: 'rallybutton',
                                    text: 'Refresh Votes',
                                    margin: 10,
                                    width: 100,
                                    handler: function() {
                                        me._doVotes();
                                    }
                                },
                                {
                                    xtype: 'rallybutton',
                                    itemId: 'revealvotesbtn',
                                    text: 'Reveal Votes',
                                    margin: 10,
                                    width: 100,
                                    disabled: true,
                                    handler: function() {
                                        me._revealVotes = !me._revealVotes;
                                        me._setVotes(me._votes);
                                    }
                                },
                                {
                                    xtype: 'rallybutton',
                                    margin: 10,
                                    width: 100,
                                    text: 'Delete Votes',
                                    handler: function() {
                                        me.app.fireEvent('removeGame');
                                    }
                                }
                            ]
                        }
                    ]
                }
            );
        }
        else {
            //We are a user here, so we can add the size selectors to the actions panel and add a vote button
            page.down('#actions').add( {
                xtype: 'label',
                itemId: 'votemessage',
                grow: true,
                margin: 10,
                hideLabel: true,
                readOnly: true,
                html: 'Choose an item &rarr; ',
                cls: 'clearpanel timertext'
            });
            var szsp = Ext.create('Ext.panel.Panel',
                {
                    xtype: 'panel',
                    itemId: 'sizespace',
                    margin: 10,
                    layout: {
                        type: 'table',
                        columns: 2,
                    },
                    bodyCls: 'userpanel',
                }
            );
            page.down('#actions').add(szsp);
            _.each(valueSeries, function(value) {
                var card = Ext.create('Niks.Apps.PokerCard', {
                    width: 150,
                    height: 80
                });
                szsp.add(card);
                value.tshirt = me[userConfigName].useTShirt;
                card.setVoteSize(value);
            });
        }
        me.app.add(page);

        var cs = page.down('#cardspaceparent');
        cs.removeCls('x-panel-body-default');
        var numcols = Math.floor(cs.getWidth()/(cardWidth+(2*cardMargin)));
        numcols = (numcols>0)? numcols: 1;
        cs.add( {
            xtype: 'panel',
            itemId: 'cardspace',
            margin: 10,
            layout: {
                type: 'table',
                columns: numcols,
            },
            bodyCls: 'userpanel',
        });

        if (this.userOrModerator) {
            page.down('#menu').add({
                xtype: 'rallybutton',
                width: 100,
                text: 'Config',
                margin: '10 10 0 10',
                handler: function() {
                    me.app.fireEvent('showConfig');
                }
            });
            page.down('#menu').add({
                xtype: 'rallybutton',
                itemId: 'iterationButton',
                width: 100,
                text: 'Iteration',
                margin: '10 10 0 10',
                handler: function() {
                    me.app.fireEvent('changeIteration');
                }
            });
            
        }
        else {
            page.down('#menu').add({
                xtype: 'rallybutton',
                width: 100,
                disabled: true,
                itemId: 'voteNow',
                text: 'Vote Now',
                margin: '10 10 0 10',
                handler: function() {
                        me.app.fireEvent('postvote');
                }
            });
        }
        page.down('#menu').add({
            xtype: 'rallybutton',
            width: 100,
            text: 'Reload Game',
            margin: '10 10 0 10',
            handler: function() {
                me.app.fireEvent('refresh');
            }
        });

        return page;
    }

});
                Ext.define('Niks.Apps.PokerIterationConfig', {
    extend: Niks.Apps.Panel,
    id: iterConfigName+'Panel',
    constructor: function() {
        this.callParent(arguments);
        this[iterConfigName] = {
            currentIteration: null
        };
    },

    getConfig: function() {
        return this[iterConfigName];
    },
    setConfig: function(config) {
        Ext.merge(this[iterConfigName], config);
    },
    
    _createPanel: function() {
        var me = this;
        var panel = Ext.create('Ext.panel.Panel', {
            floating: true,
            draggable: true,
            width: 400,
            baseCls: 'configPanel',
            hidden: true,
            closable: true,
            closeAction: 'hide',
        });

        me.getCurrentIteration().then( {
            success: function(iteration) {
                panel.add( {
                    xtype: 'rallyiterationcombobox',
                    margin: 40,
                    hideTrigger: true,
                    store: me._iterationStore,
                    storeConfig: {
                        autoLoad: false
                    },
                    value: iteration,
                    listeners: {
                        select: function(store,record) {
                            if (Array.isArray(record)){
                                me[iterConfigName].currentIteration = record[0].get('_ref');
                            } else {
                                me[iterConfigName].currentIteration = record.get('_ref');
                            }
                            me.app.fireEvent(configChange);
                        }
                    }
                });

            }

            // Don't need failure as we post error essage in _getIterations
            // failure: function() {
            //     Rally.ui.notify.Notifier.showWarning({message: 'Cannot fetch iterations for config panel'});
            // }
        });
        me.configPanel = panel;
        return panel;
    },

    getCurrentIteration: function() {
        var me = this;
        if (!this[iterConfigName].currentIteration) {
            return this._getIterations(true);
        }
        else {
            var deferred = Ext.create("Deft.Deferred");
            if (!me._iterationStore) {
                me._getIterations(false).then({
                    success: function() {
                        deferred.resolve( me[iterConfigName].currentIteration);
                    }
                });
            } else {
                deferred.resolve( me[iterConfigName].currentIteration);   /* Resolve straightaway as we already have it. */
            }
            return deferred.promise;
        }
    },

    _getIterations: function(setIteration) {

        var me =this;
        /** In this project, find the iteration that is ongoing */
        var deferred = Ext.create("Deft.Deferred");

        Ext.create('Rally.data.wsapi.Store', {
            model: Ext.identityFn('Iteration'),
            autoLoad: true,
            context: me.app.getContext().getDataContext(),
            fetch: ["Name", "StartDate", "EndDate", "ObjectID", "State", "PlannedVelocity"],
            filters: [
                {
                    property: "EndDate",
                    operator: ">",
                    value: new Date()
                }
            ],
            sorters: [
                {
                    property: 'StartDate',
                    direction: 'ASC'
                }
            ],
            listeners: {
                load: function(store, records, success) {
                    if (success) {
                        me._iterationStore = store;
                        if (setIteration) {
                            if (store.totalCount) {
                                me[iterConfigName].currentIteration = store.getAt(0).get('_ref');
                            }
                        }
                        deferred.resolve(me[iterConfigName].currentIteration);
                    }
                    else {
                        Rally.ui.notify.Notifier.showWarning({message: 'No appropriate Iterations available'});
                        deferred.reject();
                    }
                }
            }
        });
        return deferred.promise;
    },

});

            Rally.launchApp('Niks.Apps.PlanningGame', {
                name:"PlanningGame",
                parentRepos:"",
                version:"0.1.1"
            });

        });
    </script>



    <style type="text/css">
        .userpanel {
  border-left: 1px solid black;
  border-top: none;
  border-right: 1px solid black;
  border-bottom: none;
  background-color: whitesmoke;
}
.clearpanel {
  border: none;
}
.configPanel {
  opacity: 1;
  background-color: powderblue;
}
.configPanelTitle {
  border-style: none none solid none;
  border-color: black;
  border-width: 1px;
  font-size: 14px;
  background-color: powderblue;
}
.definedfield {
  border-style: none none solid none;
  border-color: black;
  border-width: 1px;
}
.erroredfield {
  border-style: none none solid none;
  border-color: red;
  border-width: 1px;
}
.timertext {
  font-size: 36px;
}
.timerrunning {
  background-color: teal;
}
.timerfinished {
  background-color: tomato;
}
.timerreset {
  background-color: white;
}
.cardtext {
  color: black;
  font-size: 12px;
  margin-left: 5px;
}
.cardSelected {
  border: 3px #00a9e0 solid;
}
.rightAlignField {
  text-align: right;
  width: 60%;
  flex: auto;
}
@keyframes textBlink {
  50% {
    opacity: 0.5;
  }
}
@-webkit-keyframes textBlink {
  50% {
    opacity: 0.5;
  }
}
.textBlink {
  animation: textBlink 1s step-start 0s infinite;
  -webkit-animation: textBlink 1s step-start 0s infinite;
}
.votesize {
  color: black;
  width: 100px;
  height: 30px;
}
.votedate {
  color: black;
  width: 140px;
  height: 30px;
}
.votename {
  color: black;
  width: 160px;
  height: 30px;
}
.buttonpushed {
  color: #78bee0;
}
.votestext {
  font-size: 24px;
  text-align: 'center';
  border-style: solid none none none;
  border-color: lightgrey;
  border-width: 2px;
}

    </style>
</head>
<body>
</body>
</html>
